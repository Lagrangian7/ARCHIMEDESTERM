<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Retro Terminal Space Invaders with UFO Random Firing</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
<script>
let invaders = [];
let particles = [];
let stars = [];
let ufo = null; // Track UFO state
let ufoLasers = []; // Track UFO lasers
let planetAngle = 0; // Rotation angle for planet and glow
let glowPulseAngle = 0; // Angle for glow pulsation
let level = 1; // Game level
let pattern = 'wheel'; // Start with wheel pattern
let score = 0; // Track player score
let limbAnimationSpeed; // Initialize in setup
let limbAnimationAmplitude = 2; // 2-pixel movement
const baseNumInvaders = 5; // Base number of invaders
const numStars = 100; // Number of stars in starfield
const baseWheelRadius = 150;
const baseRectWidth = 200;
const baseRectHeight = 100;
const baseFigure8Width = 150;
const baseFigure8Height = 100;
const combinedScale = 0.5; // Scale for combined pattern
const baseSpeed = 0.02;
const jitterAmplitude = 20; // Amplitude for random jitter
const avoidanceRadius = 150; // Distance within which invaders react to mouse
const avoidanceStrength = 0.1; // How strongly invaders move away
const maxAvoidanceSpeed = 2; // Limit avoidance speed
const planetRadius = 50; // Planet size
const planetRotationSpeed = 0.01; // Slow rotation
const planetZ = 800; // Depth for planet in starfield
const glowRadius = 60; // Glow size (larger than planet)
const glowPulseSpeed = 0.05; // Speed of glow pulsation
const ufoSpawnInterval = 20 * 60; // 20 seconds at 60 FPS
const ufoSpeed = 5; // Pixels per frame
const ufoPoints = 50; // Bonus points for hitting UFO
const ufoLaserSpeed = 5; // Laser speed (magnitude)
const ufoFireProbability = 0.05; // Reduced to 5% chance per frame
const pointsPerHit = 10; // Points awarded per invader hit
const blinkInterval = 30; // Frames for eye/nose blink (0.5s at 60 FPS)
const ufoHaloSize = 60; // Red halo size for UFO (1.5x body width)
const multiplyProbability = 0.3; // 30% chance for invader to multiply on UFO laser hit

function setup() {
  createCanvas(windowWidth, windowHeight);
  limbAnimationSpeed = TWO_PI / 20; // Initialize here to access TWO_PI
  spawnInvaders();
  // Initialize starfield
  for (let i = 0; i < numStars; i++) {
    stars.push({
      x: random(-width, width),
      y: random(-height, height),
      z: random(100, 1000) // Depth range for stars
    });
  }
}

function spawnInvaders() {
  invaders = [];
  const { spread } = getLevelModifiers();
  const wheelRadius = baseWheelRadius * spread;
  const rectWidth = baseRectWidth * spread;
  const rectHeight = baseRectHeight * spread;
  const figure8Width = baseFigure8Width * spread;
  const figure8Height = baseFigure8Height * spread;
  const numInvaders = Math.ceil(baseNumInvaders * Math.pow(1.05, level - 1)); // 5% increase per level, rounded up

  if (pattern === 'wheel') {
    for (let i = 0; i < numInvaders; i++) {
      let angle = (TWO_PI / numInvaders) * i;
      invaders.push({
        angle: angle,
        color: color(0, random(100, 200), 0), // Shades of green
        type: i % 3, // 0: squid, 1: crab, 2: skull
        pattern: 'wheel',
        noiseSeedX: random(10000),
        noiseSeedY: random(10000),
        noiseT: 0
      });
    }
  } else if (pattern === 'rectangle') {
    for (let i = 0; i < numInvaders; i++) {
      let t = (1 / numInvaders) * i;
      invaders.push({
        t: t,
        color: color(0, random(100, 200), 0),
        type: i % 3,
        pattern: 'rectangle',
        noiseSeedX: random(10000),
        noiseSeedY: random(10000),
        noiseT: 0
      });
    }
  } else if (pattern === 'figure8') {
    for (let i = 0; i < numInvaders; i++) {
      let t = (1 / numInvaders) * i;
      invaders.push({
        t: t,
        color: color(0, random(100, 200), 0),
        type: i % 3,
        pattern: 'figure8',
        noiseSeedX: random(10000),
        noiseSeedY: random(10000),
        noiseT: 0
      });
    }
  } else {
    for (let i = 0; i < numInvaders; i++) {
      let t = (1 / numInvaders) * i;
      invaders.push({
        t: t,
        color: color(0, random(100, 200), 0),
        type: i % 3,
        pattern: 'combined',
        noiseSeedX: random(10000),
        noiseSeedY: random(10000),
        noiseT: 0
      });
    }
  }
}

function spawnUfo() {
  let startLeft = random() > 0.5; // Randomly start from left or right
  let y = random(-height / 4, height / 4); // Random y position in world coordinates
  ufo = {
    x: startLeft ? -width / 2 : width / 2, // Start off-screen
    y: y,
    speed: startLeft ? ufoSpeed : -ufoSpeed, // Move right or left
    active: true
  };
}

function getLevelModifiers() {
  if (level <= 4) return { speed: baseSpeed, spread: 1 };
  else if (level <= 8) return { speed: baseSpeed * 1.2, spread: 1.2 };
  else if (level <= 12) return { speed: baseSpeed * 1.44, spread: 1.44 };
  else return { speed: baseSpeed * 1.728, spread: 1.728 };
}

function getWheelPosition(t, spread) {
  let x = cos(t * TWO_PI) * (baseWheelRadius * spread);
  let y = sin(t * TWO_PI) * (baseWheelRadius * spread);
  return { x, y };
}

function getRectangularPosition(t, spread) {
  let perimeter = 2 * (baseRectWidth * spread + baseRectHeight * spread);
  let dist = t * perimeter;
  let x, y;
  
  if (dist < baseRectWidth * spread) {
    x = -(baseRectWidth * spread) / 2 + dist;
    y = -(baseRectHeight * spread) / 2;
  } else if (dist < (baseRectWidth * spread + baseRectHeight * spread)) {
    x = (baseRectWidth * spread) / 2;
    y = -(baseRectHeight * spread) / 2 + (dist - baseRectWidth * spread);
  } else if (dist < 2 * baseRectWidth * spread + baseRectHeight * spread) {
    x = (baseRectWidth * spread) / 2 - (dist - (baseRectWidth * spread + baseRectHeight * spread));
    y = (baseRectHeight * spread) / 2;
  } else {
    x = -(baseRectWidth * spread) / 2;
    y = (baseRectHeight * spread) / 2 - (dist - (2 * baseRectWidth * spread + baseRectHeight * spread));
  }
  return { x, y };
}

function getFigure8Position(t, spread) {
  let angle = t * TWO_PI;
  let x = (baseFigure8Width * spread * cos(angle)) / (1 + pow(sin(angle), 2));
  let y = (baseFigure8Height * spread * sin(angle) * cos(angle)) / (1 + pow(sin(angle), 2));
  return { x, y };
}

function getCombinedPosition(t, spread) {
  let wheelPos = getWheelPosition(t, spread);
  let rectPos = getRectangularPosition(t, spread);
  let fig8Pos = getFigure8Position(t, spread);
  let x = (wheelPos.x + rectPos.x + fig8Pos.x) * combinedScale;
  let y = (wheelPos.y + rectPos.y + fig8Pos.y) * combinedScale;
  return { x, y };
}

function draw() {
  background(0); // Black background for terminal aesthetic
  
  // Spawn UFO every 20 seconds
  if (frameCount % ufoSpawnInterval === 0) {
    spawnUfo();
  }

  // Draw starfield
  translate(width / 2, height / 2); // Center for starfield and planet
  for (let star of stars) {
    star.z -= 5;
    if (star.z <= 0) {
      star.x = random(-width, width);
      star.y = random(-height, height);
      star.z = 1000;
    }
    let sx = (star.x / star.z) * 200;
    let sy = (star.y / star.z) * 200;
    let size = map(star.z, 1000, 0, 1, 4);
    fill(255, 255, 255, 100);
    noStroke();
    rect(sx, sy, size, size);
  }

  // Draw rotating planet with glow effect
  push();
  let planetX = width / 4; // Position in top-right quadrant
  let planetY = -height / 4;
  let planetScreenX = (planetX / planetZ) * 200;
  let planetScreenY = (planetY / planetZ) * 200;
  let planetScreenRadius = (planetRadius / planetZ) * 200;
  let glowScreenRadius = (glowRadius / planetZ) * 200;
  translate(planetScreenX, planetScreenY);
  rotate(planetAngle);
  // Draw glow
  let glowAlpha = map(sin(glowPulseAngle), -1, 1, 50, 100); // Pulsate between 50 and 100
  fill(0, 255, 0, glowAlpha); // Bright green glow
  noStroke();
  ellipse(0, 0, glowScreenRadius * 2);
  // Draw planet
  fill(0, 100, 0, 150); // Muted green with alpha
  ellipse(0, 0, planetScreenRadius * 2); // Planet body
  fill(0, 50, 0, 150); // Darker green for craters
  ellipse(-planetScreenRadius * 0.5, -planetScreenRadius * 0.3, planetScreenRadius * 0.4); // Crater 1
  ellipse(planetScreenRadius * 0.3, planetScreenRadius * 0.4, planetScreenRadius * 0.3); // Crater 2
  ellipse(0, -planetScreenRadius * 0.6, planetScreenRadius * 0.2); // Crater 3
  pop();
  planetAngle += planetRotationSpeed;
  glowPulseAngle += glowPulseSpeed;

  // Update and draw UFO
  if (ufo && ufo.active) {
    ufo.x += ufo.speed;
    // Check if UFO is off-screen
    if (ufo.x < -width / 2 - 50 || ufo.x > width / 2 + 50) {
      ufo = null;
    } else {
      // Fire laser every frame in random direction
      if (random() < ufoFireProbability) {
        let angle = random(TWO_PI); // Random direction
        ufoLasers.push({
          x: ufo.x,
          y: ufo.y + 10, // Start below UFO
          vx: cos(angle) * ufoLaserSpeed, // Random x velocity
          vy: sin(angle) * ufoLaserSpeed // Random y velocity
        });
      }
      // Draw UFO
      push();
      translate(ufo.x, ufo.y);
      // Draw red halo
      fill(255, 0, 0, glowAlpha); // Bright red, synchronized with glow pulse
      noStroke();
      ellipse(0, 0, ufoHaloSize); // Halo size 60 pixels
      // Draw UFO body
      fill(0, 150, 0); // Medium green for UFO body
      ellipse(0, 0, 40, 15); // Flat oval body
      fill(0, 100, 0); // Darker green for dome
      arc(0, 0, 20, 20, PI, TWO_PI); // Top dome
      fill(0, 255, 0); // Bright green lights
      ellipse(-15, 5, 5, 5); // Left light
      ellipse(0, 5, 5, 5); // Center light
      ellipse(15, 5, 5, 5); // Right light
      pop();
    }
  }

  // Update and draw UFO lasers
  for (let i = ufoLasers.length - 1; i >= 0; i--) {
    let laser = ufoLasers[i];
    laser.x += laser.vx;
    laser.y += laser.vy;
    // Remove laser if off-screen
    if (laser.x < -width / 2 - 50 || laser.x > width / 2 + 50 || 
        laser.y < -height / 2 - 50 || laser.y > height / 2 + 50) {
      ufoLasers.splice(i, 1);
      continue;
    }
    // Draw laser
    fill(0, 255, 0); // Bright green
    noStroke();
    rect(laser.x, laser.y, 5, 5);
    // Check for invader hits
    const { spread } = getLevelModifiers();
    for (let j = invaders.length - 1; j >= 0; j--) {
      let invader = invaders[j];
      let x, y;
      if (invader.pattern === 'wheel') {
        let baseX = cos(invader.angle) * (baseWheelRadius * spread);
        let baseY = sin(invader.angle) * (baseWheelRadius * spread);
        let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        x = baseX + jitterX;
        y = baseY + jitterY;
      } else if (invader.pattern === 'rectangle') {
        let pos = getRectangularPosition(invader.t, spread);
        let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        x = pos.x + jitterX;
        y = pos.y + jitterY;
      } else if (invader.pattern === 'figure8') {
        let pos = getFigure8Position(invader.t, spread);
        let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        x = pos.x + jitterX;
        y = pos.y + jitterY;
      } else {
        let pos = getCombinedPosition(invader.t, spread);
        let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
        x = pos.x + jitterX;
        y = pos.y + jitterY;
      }
      // Apply avoidance offset
      let mouseXWorld = mouseX - width / 2;
      let mouseYWorld = mouseY - height / 2;
      let dx = x - mouseXWorld;
      let dy = y - mouseYWorld;
      let distance = sqrt(dx * dx + dy * dy);
      if (distance < avoidanceRadius && distance > 0) {
        let avoidX = (dx / distance) * avoidanceStrength;
        let avoidY = (dy / distance) * avoidanceStrength;
        let avoidMag = sqrt(avoidX * avoidX + avoidY * avoidY);
        if (avoidMag > maxAvoidanceSpeed) {
          avoidX = (avoidX / avoidMag) * maxAvoidanceSpeed;
          avoidY = (avoidY / avoidMag) * maxAvoidanceSpeed;
        }
        x += avoidX;
        y += avoidY;
      }
      x += width / 2;
      y += height / 2;
      // Check laser collision
      if (laser.x > x - 15 && laser.x < x + 15 && laser.y > y - 15 && laser.y < y + 15) {
        // Randomly multiply or destroy
        if (random() < multiplyProbability) {
          // Multiply: Add a new invader near the hit one
          let newInvader = {...invader}; // Copy properties
          newInvader.angle = invader.angle + random(-0.1, 0.1); // Slight offset for wheel
          newInvader.t = invader.t + random(-0.05, 0.05); // Slight offset for other patterns
          newInvader.noiseSeedX = random(10000); // New noise seeds
          newInvader.noiseSeedY = random(10000);
          newInvader.noiseT = 0;
          invaders.push(newInvader);
        } else {
          // Destroy
          for (let k = 0; k < 20; k++) {
            particles.push({
              x: x - width / 2,
              y: y - height / 2,
              vx: random(-2, 2),
              vy: random(-2, 2),
              lifetime: 25
            });
          }
          invaders.splice(j, 1);
        }
        ufoLasers.splice(i, 1);
        score += pointsPerHit;
        break;
      }
    }
  }

  // Draw and update each invader
  const { speed, spread } = getLevelModifiers();
  const limbOffset = sin(frameCount * limbAnimationSpeed) * limbAnimationAmplitude; // +/- 2 pixels
  for (let i = invaders.length - 1; i >= 0; i--) {
    let invader = invaders[i];
    let x, y;
    
    if (invader.pattern === 'wheel') {
      x = cos(invader.angle) * (baseWheelRadius * spread);
      y = sin(invader.angle) * (baseWheelRadius * spread);
      invader.angle += speed;
    } else if (invader.pattern === 'rectangle') {
      let pos = getRectangularPosition(invader.t, spread);
      x = pos.x;
      y = pos.y;
      invader.t = (invader.t + speed / 10) % 1;
    } else if (invader.pattern === 'figure8') {
      let pos = getFigure8Position(invader.t, spread);
      x = pos.x;
      y = pos.y;
      invader.t = (invader.t + speed / 10) % 1;
    } else {
      let pos = getCombinedPosition(invader.t, spread);
      x = pos.x;
      y = pos.y;
      invader.t = (invader.t + speed / 10) % 1;
    }
    
    // Add random jitter using Perlin noise
    invader.noiseT += 0.01;
    let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
    let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
    x += jitterX;
    y += jitterY;

    // Add avoidance behavior
    let mouseXWorld = mouseX - width / 2;
    let mouseYWorld = mouseY - height / 2;
    let dx = x - mouseXWorld;
    let dy = y - mouseYWorld;
    let distance = sqrt(dx * dx + dy * dy);
    if (distance < avoidanceRadius && distance > 0) {
      let avoidX = (dx / distance) * avoidanceStrength;
      let avoidY = (dy / distance) * avoidanceStrength;
      let avoidMag = sqrt(avoidX * avoidX + avoidY * avoidY);
      if (avoidMag > maxAvoidanceSpeed) {
        avoidX = (avoidX / avoidMag) * maxAvoidanceSpeed;
        avoidY = (avoidY / avoidMag) * maxAvoidanceSpeed;
      }
      x += avoidX;
      y += avoidY;
    }
    
    // Draw invader with glow, blinking eyes, and animated limbs
    push();
    translate(x, y);
    // Draw glow
    fill(0, 255, 0, glowAlpha); // Synchronized with planet glow
    noStroke();
    let glowSize = invader.type === 0 ? 30 : invader.type === 1 ? 37.5 : 30; // 1.5x body size
    ellipse(0, 0, glowSize);
    // Draw invader body
    fill(invader.color);
    noStroke();
    if (invader.type === 0) {
      rectMode(CENTER);
      rect(0, 0, 20, 15); // Body (static)
      rect(-10, -10 + limbOffset, 5, 5); // Left antenna (up/down)
      rect(10, -10 + limbOffset, 5, 5); // Right antenna (up/down)
      rect(-5, 10 + limbOffset, 5, 5); // Left leg (up/down)
      rect(5, 10 + limbOffset, 5, 5); // Right leg (up/down)
      // Blinking eyes
      if (frameCount % (2 * blinkInterval) < blinkInterval) {
        fill(0, 255, 0); // Bright green eyes
        rect(-5, -2, 3, 3);
        rect(5, -2, 3, 3);
      }
    } else if (invader.type === 1) {
      rectMode(CENTER);
      rect(0, 0, 25, 15); // Body (static)
      rect(-15 + limbOffset, 0, 5, 5); // Left arm (left/right)
      rect(15 - limbOffset, 0, 5, 5); // Right arm (left/right)
      rect(-10, 10 + limbOffset, 5, 5); // Left leg (up/down)
      rect(10, 10 + limbOffset, 5, 5); // Right leg (up/down)
      // Blinking eyes
      if (frameCount % (2 * blinkInterval) < blinkInterval) {
        fill(0, 255, 0); // Bright green eyes
        rect(-5, 0, 3, 3);
        rect(5, 0, 3, 3);
      }
    } else {
      rectMode(CENTER);
      rect(0, 0, 20, 20); // Head (static)
      rect(-10, 10 + limbOffset, 5, 5); // Left lower (up/down)
      rect(10, 10 + limbOffset, 5, 5); // Right lower (up/down)
      fill(0); // Black eye sockets
      rect(-5, -2, 4, 4);
      rect(5, -2, 4, 4);
      // Blinking nose
      if (frameCount % (2 * blinkInterval) < blinkInterval) {
        fill(0, 255, 0); // Bright green nose
        rect(0, 5, 3, 3);
      }
    }
    pop();
  }

  // Update and draw particles for explosion effect
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.lifetime -= 1;
    fill(0, 255, 0, p.lifetime * 10); // Fade out green particles
    noStroke();
    rect(p.x, p.y, 3, 3);
    if (p.lifetime <= 0) {
      particles.splice(i, 1);
    }
  }

  translate(-width / 2, -height / 2); // Reset translation for score

  // Draw score and level at top center
  textAlign(CENTER, TOP);
  textSize(24);
  fill(0, 255, 0); // Bright green for score
  text(`Score: ${score} | Level: ${level}`, width / 2, 20);

  // Check for level completion
  if (invaders.length === 0) {
    level++;
    pattern = level % 4 === 1 ? 'wheel' : level % 4 === 2 ? 'rectangle' : level % 4 === 3 ? 'figure8' : 'combined';
    spawnInvaders();
  }
}

function mousePressed() {
  const { spread } = getLevelModifiers();
  
  // Check for UFO hit
  if (ufo && ufo.active) {
    let ufoScreenX = ufo.x + width / 2;
    let ufoScreenY = ufo.y + height / 2;
    if (mouseX > ufoScreenX - 20 && mouseX < ufoScreenX + 20 && mouseY > ufoScreenY - 10 && mouseY < ufoScreenY + 10) {
      for (let j = 0; j < 20; j++) {
        particles.push({
          x: ufo.x,
          y: ufo.y,
          vx: random(-2, 2),
          vy: random(-2, 2),
          lifetime: 25
        });
      }
      ufo = null;
      score += ufoPoints;
      return; // Prevent checking invaders if UFO is hit
    }
  }

  // Check for invader hit
  for (let i = invaders.length - 1; i >= 0; i--) {
    let invader = invaders[i];
    let x, y;
    if (invader.pattern === 'wheel') {
      let baseX = cos(invader.angle) * (baseWheelRadius * spread);
      let baseY = sin(invader.angle) * (baseWheelRadius * spread);
      let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      x = baseX + jitterX;
      y = baseY + jitterY;
    } else if (invader.pattern === 'rectangle') {
      let pos = getRectangularPosition(invader.t, spread);
      let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      x = pos.x + jitterX;
      y = pos.y + jitterY;
    } else if (invader.pattern === 'figure8') {
      let pos = getFigure8Position(invader.t, spread);
      let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      x = pos.x + jitterX;
      y = pos.y + jitterY;
    } else {
      let pos = getCombinedPosition(invader.t, spread);
      let jitterX = noise(invader.noiseSeedX + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      let jitterY = noise(invader.noiseSeedY + invader.noiseT) * jitterAmplitude * 2 - jitterAmplitude;
      x = pos.x + jitterX;
      y = pos.y + jitterY;
    }
    
    // Apply avoidance offset for hit detection
    let mouseXWorld = mouseX - width / 2;
    let mouseYWorld = mouseY - height / 2;
    let dx = x - mouseXWorld;
    let dy = y - mouseYWorld;
    let distance = sqrt(dx * dx + dy * dy);
    if (distance < avoidanceRadius && distance > 0) {
      let avoidX = (dx / distance) * avoidanceStrength;
      let avoidY = (dy / distance) * avoidanceStrength;
      let avoidMag = sqrt(avoidX * avoidX + avoidY * avoidY);
      if (avoidMag > maxAvoidanceSpeed) {
        avoidX = (avoidX / avoidMag) * maxAvoidanceSpeed;
        avoidY = (avoidY / avoidMag) * maxAvoidanceSpeed;
      }
      x += avoidX;
      y += avoidY;
    }
    
    x += width / 2;
    y += height / 2;
    
    if (mouseX > x - 15 && mouseX < x + 15 && mouseY > y - 15 && mouseY < y + 15) {
      for (let j = 0; j < 20; j++) {
        particles.push({
          x: x - width / 2,
          y: y - height / 2,
          vx: random(-2, 2),
          vy: random(-2, 2),
          lifetime: 25
        });
      }
      invaders.splice(i, 1);
      score += pointsPerHit;
      break;
    }
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>